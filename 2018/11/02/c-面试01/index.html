<!DOCTYPE html>
<a href="https://github.com/FelixRong/FelixRong.github.io"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_green_007200.png" alt="Fork me on GitHub"></a>


  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">






  
  
  <link rel="stylesheet" media="all" href="/lib/Han/dist/han.min.css?v=3.3">




<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="c++,">










<meta name="description" content="1、 引用和指针的区别1)    指针是一个实体，需要分配内存空间。引用只是变量的别名，不需要分配内存空间。2)    引用在定义的时候必须进行初始化，并且不能够改变。指针在定义的时候不一定要初始化，并且指向的空间可变。（注：不能有引用的值不能为NULL）3)    有多级指针，但是没有多级引用，只能有一级引用。4)    指针和引用的自增运算结果不一样。（指针是指向下一个空间，引用时引用的变量值">
<meta name="keywords" content="c++">
<meta property="og:type" content="article">
<meta property="og:title" content="c++面试01">
<meta property="og:url" content="http://yoursite.com/2018/11/02/c-面试01/index.html">
<meta property="og:site_name" content="张凡荣">
<meta property="og:description" content="1、 引用和指针的区别1)    指针是一个实体，需要分配内存空间。引用只是变量的别名，不需要分配内存空间。2)    引用在定义的时候必须进行初始化，并且不能够改变。指针在定义的时候不一定要初始化，并且指向的空间可变。（注：不能有引用的值不能为NULL）3)    有多级指针，但是没有多级引用，只能有一级引用。4)    指针和引用的自增运算结果不一样。（指针是指向下一个空间，引用时引用的变量值">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/images/c++/1.png">
<meta property="og:image" content="http://yoursite.com/images/c++/2.png">
<meta property="og:updated_time" content="2018-11-02T13:41:52.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="c++面试01">
<meta name="twitter:description" content="1、 引用和指针的区别1)    指针是一个实体，需要分配内存空间。引用只是变量的别名，不需要分配内存空间。2)    引用在定义的时候必须进行初始化，并且不能够改变。指针在定义的时候不一定要初始化，并且指向的空间可变。（注：不能有引用的值不能为NULL）3)    有多级指针，但是没有多级引用，只能有一级引用。4)    指针和引用的自增运算结果不一样。（指针是指向下一个空间，引用时引用的变量值">
<meta name="twitter:image" content="http://yoursite.com/images/c++/1.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/11/02/c-面试01/">





  <title>c++面试01 | 张凡荣</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">张凡荣</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">QQ:953418392</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/02/c-面试01/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="FelixRong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/next/tx.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张凡荣">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">c++面试01</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-02T20:23:57+08:00">
                2018-11-02
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/校园招聘/" itemprop="url" rel="index">
                    <span itemprop="name">校园招聘</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/11/02/c-面试01/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count gitment-comments-count" data-xid="/2018/11/02/c-面试01/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2018/11/02/c-面试01/" class="leancloud_visitors" data-flag-title="c++面试01">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        <h2 id="1、-引用和指针的区别"><a href="#1、-引用和指针的区别" class="headerlink" title="1、 引用和指针的区别"></a>1、 引用和指针的区别</h2><p>1)    指针是一个<span style="color: red">实体</span>，需要分配内存空间。引用只是变量的<span style="color: red">别名</span>，不需要分配内存空间。<br>2)    引用在定义的时候<span style="color: red">必须进行初始化</span>，并且不能够改变。指针在定义的时候不一定要初始化，并且指向的空间可变。（注：不能有引用的值不能为NULL）<br>3)    有<span style="color: red">多级指针</span>，但是没有多级引用，只能有一级引用。<br>4)    指针和引用的自增运算结果不一样。（指针是指向下一个空间，引用时引用的变量值加1）<br>5)    <span style="color: red">sizeof</span> 引用得到的是所指向的变量（对象）的大小，而sizeof 指针得到的是指针本身的大小。<br><a id="more"></a><br>6)    引用访问一个变量是直接访问，而指针访问一个变量是间接访问。<br>7)    使用指针前最好<span style="color: red">做类型检查</span>，防止野指针的出现；<br>8)    <span style="color: red">引用底层</span>是通过指针实现的；<br>9)    作为参数时也不同，传指针的实质是传值，传递的值是指针的地址；传引用的实质是传地址，传递的是变量的地址。</p>
<h2 id="2、-C-中的指针参数传递和引用参数传递"><a href="#2、-C-中的指针参数传递和引用参数传递" class="headerlink" title="2、 C++中的指针参数传递和引用参数传递"></a>2、 C++中的指针参数传递和引用参数传递</h2><p>1)    指针参数传递本质上是<span style="color: red">值传递</span>，它所传递的是一个<span style="color: red">地址值</span>。值传递过程中，被调函数的形式参数作为被调函数的局部变量处理，会在<span style="color: red">栈中开辟内存空间</span>以存放由主调函数传递进来的实参值，从而形成了实参的一个副本（替身）。值传递的特点是，被调函数对形式参数的任何操作都是作为局部变量进行的，不会影响主调函数的实参变量的值（形参指针变了，实参指针不会变）。</p>
<p>2)    引用参数传递过程中，被调函数的形式参数也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的<span style="color: red">实参变量的地址</span>。被调函数对形参（本体）的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量（根据别名找到主调函数中的本体）。因此，被调函数对形参的任何操作都会影响主调函数中的实参变量。</p>
<p>3)    <span style="color: red">引用传递和指针传递是不同的</span>，虽然他们都是在被调函数栈空间上的一个局部变量，但是任何对于引用参数的处理都会通过一个间接寻址的方式操作到主调函数中的相关变量。而对于指针传递的参数，如果改变被调函数中的指针地址，它将应用不到主调函数的相关变量。如果想通过指针参数传递来改变主调函数中的相关变量（地址），那就得使用指向指针的指针或者指针引用。</p>
<p>4)    从<span style="color: red">编译</span>的角度来讲，程序在编译时分别将指针和引用添加到符号表上，符号表中记录的是变量名及变量所对应地址。指针变量在符号表上对应的地址值为指针变量的地址值，而引用在符号表上对应的地址值为引用对象的地址值（与实参名字不同，地址相同）。符号表生成之后就不会再改，因此指针可以改变其指向的对象（指针变量中的值可以改），而引用对象则不能修改。</p>
<h2 id="3、-形参与实参的区别"><a href="#3、-形参与实参的区别" class="headerlink" title="3、 形参与实参的区别"></a>3、 形参与实参的区别</h2><p>1)    形参变量只有在<span style="color: red">被调用时才分配内存单元，</span>在调用结束时， 即刻释放所分配的内存单元。因此，<span style="color: red">形参只有在函数内部有效</span>。 函数调用结束返回主调函数后则不能再使用该形参变量。</p>
<p>2)    实参可以是常量、变量、表达式、函数等， 无论实参是何种类型的量，在进行函数调用时，它们都必须具有确定的值， 以便把这些值传送给形参。 因此<span style="color: red">应预先用赋值，输入等办法使实参获得确定值，会产生一个临时变量。</span></p>
<p>3)    <span style="color: red">实参和形参在数量上，类型上，顺序上应严格一致</span>， 否则会发生“类型不匹配”的错误。</p>
<p>4)    函数调用中发生的数据传送是<span style="color: red">单向的。</span> 即只能把实参的值传送给形参，而不能把形参的值反向地传送给实参。 因此在函数调用过程中，形参的值发生改变，而实参中的值不会变化。</p>
<p>5)    当形参和实参不是指针类型时，在该函数运行时，形参和实参是不同的变量，他们在内存中位于不同的位置，形参将实参的内容复制一份，在该函数运行结束的时候形参被释放，而实参内容不会改变。</p>
<p>a)    值传递：有一个形参向函数所属的栈拷贝数据的过程，如果值传递的对象是类对象    或是大的结构体对象，将耗费一定的时间和空间。（传值）<br>b)    指针传递：同样有一个形参向函数所属的栈拷贝数据的过程，但拷贝的数据是一个固定为4字节的地址。（传值，传递的是地址值）<br>c)    引用传递：同样有上述的数据拷贝过程，但其是针对地址的，相当于为该数据所在的地址起了一个别名。（传地址）<br>d)    效率上讲，指针传递和引用传递比值传递效率高。一般主张使用引用传递，代码逻辑上更加紧凑、清晰。</p>
<h2 id="4、-static的用法和作用"><a href="#4、-static的用法和作用" class="headerlink" title="4、 static的用法和作用"></a>4、 static的用法和作用</h2><p>1.先来介绍它的第一条也是最重要的一条：<span style="color: red">隐藏。</span>（static函数，static变量均可）<br>当同时编译多个文件时，所有<span style="color: red">未加static前缀</span>的全局变量和函数都具有全局可见性。<br>2.static的第二个作用是<span style="color: red">保持变量内容的持久</span>。（static变量中的记忆功能和全局生存期）存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。共有两种变量存储在静态存储区：全局变量和static变量，只不过和全局变量比起来，static可以控制变量的可见范围，说到底static还是用来隐藏的。<br>3.static的第三个作用是<span style="color: red">默认初始化为0（static变量）</span><br>其实全局变量也具备这一属性，因为全局变量也存储在静态数据区。在静态数据区，内存中所有的字节默认值都是0x00，某些时候这一特点可以减少程序员的工作量。<br>4.static的第四个作用：<span style="color: red">C++中的类成员声明static</span><br>1)    函数体内static变量的作用范围为该函数体，不同于auto变量，该变量的内存只被分配一次，因此其值在下次调用时仍维持上次的值；<br>2)    在模块内的static全局变量可以被模块内所用函数访问，但不能被模块外其它函数访问；<br>3)    在模块内的static函数只可被这一模块内的其它函数调用，这个函数的使用范围被限制在声明它的模块内；<br>4)    在类中的<span style="color: red">static成员变量属于整个类所拥有</span>，对类的所有对象只有一份拷贝；<br>5)    在类中的<span style="color: red">static成员函数属于整个类所拥有</span>，这个函数不接收this指针，因而只能访问类的static成员变量。<br>类内：<br>6)    static类对象必须要在类外进行初始化，static修饰的变量先于对象存在，所以<span style="color: red">static修饰的变量要在类外初始化；</span><br>7)    由于static修饰的类成员属于类，不属于对象，因此static类成员函数是没有this指针的，this指针是指向本对象的指针。正因为没有this指针，所以static类成员函数不能访问非static的类成员，只能访问 static修饰的类成员；<br>8)    <span style="color: red">static成员函数不能被virtual修饰</span>，static成员不属于任何对象或实例，所以加上virtual没有任何实际意义；静态成员函数没有this指针，虚函数的实现是为每一个对象分配一个vptr指针，而vptr是通过this指针调用的，所以不能为virtual；虚函数的调用关系，this-&gt;vptr-&gt;ctable-&gt;virtual function。</p>
<h2 id="5、静态变量什么时候初始化"><a href="#5、静态变量什么时候初始化" class="headerlink" title="5、静态变量什么时候初始化"></a>5、静态变量什么时候初始化</h2><p>1)    <span style="color: red">初始化只有一次，但是可以多次赋值，</span>在主程序之前，编译器已经为其分配好了内存。<br>2)    静态局部变量和全局变量一样，数据都存放在全局区域，所以<span style="color: red">在主程序之前，编译器已经为其分配好了内存，</span>但在C和C++中静态局部变量的初始化节点又有点不太一样。在C中，初始化发生在代码执行之前，编译阶段分配好内存之后，就会进行初始化，所以我们看到在C语言中无法使用变量对静态局部变量进行初始化，在程序运行结束，变量所处的全局内存会被全部回收。<br>3)    而在<span style="color: red">C++中，初始化时在执行相关代码时才会进行初始化</span>，主要是由于C++引入对象后，要进行初始化必须执行相应构造函数和析构函数，在构造函数或析构函数中经常会需要进行某些程序中需要进行的特定操作，并非简单地分配内存。所以C++标准定为全局或静态对象是有首次用到时才会进行构造，并通过atexit()来管理。在程序结束，按照构造顺序反方向进行逐个析构。所以在C++中是可以使用变量对静态局部变量进行初始化的。</p>
<h2 id="6、-const"><a href="#6、-const" class="headerlink" title="6、 const"></a>6、 const</h2><p>1)    <span style="color: red">阻止一个变量被改变，</span>可以使用const关键字。在定义该const变量时，通常需要对它进行初始化，因为以后就没有机会再去改变它了；<br>2)    对指针来说，可以指定指针本身为const，也可以指定指针所指的数据为const，或二者同时指定为const；<br>3)    在一个函数声明中，const可以<span style="color: red">修饰形参</span>，表明它是一个输入参数，在函数内部不能改变其值；<br>4)    对于类的成员函数，若指定其为const类型，则表明其是一个常函数，不能修改类的成员变量，<span style="color: red">类的常对象只能访问类的常成员函数；</span><br>5)    对于类的成员函数，有时候必须指定其返回值为const类型，以使得其返回值不为“左值”。<br>6)    <span style="color: red">const成员函数</span>可以访问非const对象的非const数据成员、const数据成员，也可以访问const对象内的所有数据成员；<br>7)    非const成员函数可以访问非const对象的非const数据成员、const数据成员，但不可以访问const对象的任意数据成员；<br>8)    一个没有明确声明为const的成员函数被看作是将要修改对象中数据成员的函数，而且编译器不允许它为一个const对象所调用。因此const对象只能调用const成员函数。<br>9)    const类型变量可以通过类型转换符<span style="color: red">const_cast</span>将const类型转换为非const类型；<br>10)    <span style="color: red">const类型变量必须定义的时候进行初始化，</span>因此也导致如果类的成员变量有const类型的变量，那么该变量必须在类的初始化列表中进行初始化；<br>11)    对于函数值传递的情况，因为参数传递是通过复制实参创建一个临时变量传递进函数的，<span style="color: red">函数内只能改变临时变量</span>，但无法改变实参。则这个时候无论加不加const对实参不会产生任何影响。但是<span style="color: red">在引用或指针</span>传递函数调用中，因为传进去的是一个引用或指针，这样函数内部可以改变引用或指针所指向的变量，这时const 才是实实在在地保护了实参所指向的变量。因为在编译阶段编译器对调用函数的选择是根据实参进行的，所以，只有引用传递和指针传递可以用是否加const来重载。一个拥有顶层const的形参无法和另一个没有顶层const的形参区分开来。</p>
<h2 id="7、-const成员函数的理解和应用"><a href="#7、-const成员函数的理解和应用" class="headerlink" title="7、 const成员函数的理解和应用"></a>7、 const成员函数的理解和应用</h2><p>①    const Stock &amp; Stock::topval (②const Stock &amp; s) ③const<br>①处const：确保返回的Stock对象在以后的使用中不能被修改<br>②处const：确保此方法不修改传递的参数 S<br>③处const：保证此方法不修改调用它的对象，const对象只能调用const成员函数,不能调用非const函数</p>
<h2 id="8、-指针和const的用法"><a href="#8、-指针和const的用法" class="headerlink" title="8、 指针和const的用法"></a>8、 指针和const的用法</h2><p>1)    当const修饰指针时，由于const的位置不同，它的修饰对象会有所不同。<br>2)    int <em> const p2中const修饰p2的值,所以理解为p2的值不可以改变，即p2只能指向固定的一个变量地址，但可以通过</em> p2读写这个变量的值。顶层指针表示指针本身是一个常量<br>3)    int const <em> p1或者const int </em> p1两种情况中const修饰<em> p1，所以理解为</em> p1的值不可以改变，即不可以给<em> p1赋值改变p1指向变量的值，但可以通过给p赋值不同的地址改变这个指针指向。底层指针表示指针所指向的变量是一个常量。<br>4)    int const </em> const p;</p>
<h2 id="9、mutable"><a href="#9、mutable" class="headerlink" title="9、mutable"></a>9、mutable</h2><p>1)    如果需要在const成员方法中修改一个成员变量的值，那么需要将这个成员变量修饰为mutable。即用mutable修饰的成员变量不受const成员方法的限制;<br>2)    可以认为mutable的变量是类的辅助状态，但是只是起到类的一些方面表述的功能，修改他的内容我们可以认为对象的状态本身并没有改变的。实际上由于const_cast的存在，这个概念很多时候用处不是很到了。</p>
<h2 id="10、-extern用法"><a href="#10、-extern用法" class="headerlink" title="10、 extern用法"></a>10、 extern用法</h2><p>1)    extern修饰变量的声明<br>如果文件a.c需要引用b.c中变量int v，就可以在a.c中声明extern int v，然后就可以引用变量v。<br>2)    extern修饰函数的声明<br>如果文件a.c需要引用b.c中的函数，比如在b.c中原型是int fun(int mu)，那么就可以在a.c中声明extern int fun（int mu），然后就能使用fun来做任何事情。就像变量的声明一样，extern int fun（int mu）可以放在a.c中任何地方，而不一定非要放在a.c的文件作用域的范围中。<br>3)    extern修饰符可用于指示C或者C＋＋函数的调用规范。<br>比如在C＋＋中调用C库函数，就需要在C＋＋程序中用extern “C”声明要引用的函数。这是给链接器用的，告诉链接器在链接的时候用C函数规范来链接。主要原因是C＋＋和C程序编译完成后在目标代码中命名规则不同。</p>
<h2 id="11、-int转字符串字符串转int-strcat-strcpy-strncpy-memset-memcpy的内部实现？"><a href="#11、-int转字符串字符串转int-strcat-strcpy-strncpy-memset-memcpy的内部实现？" class="headerlink" title="11、 int转字符串字符串转int?strcat,strcpy,strncpy,memset,memcpy的内部实现？"></a>11、 int转字符串字符串转int?strcat,strcpy,strncpy,memset,memcpy的内部实现？</h2><p>c++11标准增加了全局函数std::to_string<br>可以使用std::stoi/stol/stoll等等函数<br>strcpy拥有返回值，有时候函数原本不需要返回值，但为了增加灵活性如支持链式表达，</p>
<h2 id="12、-深拷贝与浅拷贝？"><a href="#12、-深拷贝与浅拷贝？" class="headerlink" title="12、 深拷贝与浅拷贝？"></a>12、 深拷贝与浅拷贝？</h2><p>1)    <span style="color: red">浅复制</span> —-只是拷贝了基本类型的数据，而引用类型数据，复制后也是会发生引用，我们把这种拷贝叫做“（浅复制）浅拷贝”，换句话说，浅复制仅仅是指向被复制的内存地址，如果原地址中对象被改变了，那么浅复制出来的对象也会相应改变。<br><span style="color: red">深复制</span> —-在计算机中开辟了一块新的内存地址用于存放复制的对象。<br><img src="/images/c++/1.png" alt="内存"><img src="/images/c++/2.png" alt="深复制"><br>2)    在某些状况下，类内成员变量需要动态开辟堆内存，如果实行位拷贝，也就是把对象里的值完全复制给另一个对象，如A=B。这时，如果B中有一个成员变量指针已经申请了内存，那A中的那个成员变量也指向同一块内存。这就出现了问题：当B把内存释放了（如：析构），这时A内的指针就是野指针了，出现运行错误。</p>
<h2 id="13、C-模板是什么，底层怎么实现的？"><a href="#13、C-模板是什么，底层怎么实现的？" class="headerlink" title="13、C++模板是什么，底层怎么实现的？"></a>13、C++模板是什么，底层怎么实现的？</h2><p>1)    编译器并不是把函数模板处理成能够处理任意类的函数；编译器从函数模板通过具体类型产生不同的函数；编译器会对函数模板进行两次编译：在声明的地方对模板代码本身进行编译，在调用的地方对参数替换后的代码进行编译。<br>2)    这是因为函数模板要被实例化后才能成为真正的函数，在使用函数模板的源文件中包含函数模板的头文件，如果该头文件中只有声明，没有定义，那编译器无法实例化该模板，最终导致链接错误。</p>
<h2 id="14、C语言struct和C-struct区别"><a href="#14、C语言struct和C-struct区别" class="headerlink" title="14、C语言struct和C++struct区别"></a>14、C语言struct和C++struct区别</h2><p>1)    C语言中：struct是用户自定义数据类型（UDT）；C++中struct是抽象数据类型（ADT），支持成员函数的定义，（C++中的struct能继承，能实现多态）。<br>2)    C中struct是没有权限的设置的，且struct中只能是一些变量的集合体，可以封装数据却不可以隐藏数据，而且成员不可以是函数。<br>3)    C++中，struct的成员默认访问说明符为public（为了与C兼容），class中的默认访问限定符为private，struct增加了访问权限，且可以和类一样有成员函数。<br>4)    struct作为类的一种特例是用来自定义数据结构的。一个结构标记声明后，在C中必须在结构标记前加上struct，才能做结构类型名</p>
<h2 id="15、虚函数可以声明为inline吗"><a href="#15、虚函数可以声明为inline吗" class="headerlink" title="15、虚函数可以声明为inline吗?"></a>15、虚函数可以声明为inline吗?</h2><p>1)    虚函数用于实现运行时的多态，或者称为晚绑定或动态绑定。而内联函数用于提高效率。内联函数的原理是，在编译期间，对调用内联函数的地方的代码替换成函数代码。内联函数对于程序中需要频繁使用和调用的小函数非常有用。<br>2)    虚函数要求在运行时进行类型确定，而内敛函数要求在编译期完成相关的函数替换；</p>
<h2 id="16、类成员初始化方式？构造函数的执行顺序-？为什么用成员初始化列表会快一些？"><a href="#16、类成员初始化方式？构造函数的执行顺序-？为什么用成员初始化列表会快一些？" class="headerlink" title="16、类成员初始化方式？构造函数的执行顺序 ？为什么用成员初始化列表会快一些？"></a>16、类成员初始化方式？构造函数的执行顺序 ？为什么用成员初始化列表会快一些？</h2><p>1)    赋值初始化，通过在函数体内进行赋值初始化；列表初始化，在冒号后使用初始化列表进行初始化。<br>这两种方式的主要区别在于：<br>对于在函数体中初始化,是在所有的数据成员被分配内存空间后才进行的。<br>列表初始化是给数据成员分配内存空间时就进行初始化,就是说分配一个数据成员只要冒号后有此数据成员的赋值表达式(此表达式必须是括号赋值表达式),那么分配了内存空间后在进入函数体之前给数据成员赋值，就是说初始化这个数据成员此时函数体还未执行。<br>2)    一个派生类构造函数的执行顺序如下：<br>①    虚拟基类的构造函数（多个虚拟基类则按照继承的顺序执行构造函数）。<br>②    基类的构造函数（多个普通基类也按照继承的顺序执行构造函数）。<br>③    类类型的成员对象的构造函数（按照初始化顺序）<br>④    派生类自己的构造函数。<br>3)    方法一是在构造函数当中做赋值的操作，而方法二是做纯粹的初始化操作。我们都知道，C++的赋值操作是会产生临时对象的。临时对象的出现会降低程序的效率。</p>
<h2 id="17、成员列表初始化？"><a href="#17、成员列表初始化？" class="headerlink" title="17、成员列表初始化？"></a>17、成员列表初始化？</h2><p>1)    必须使用成员初始化的四种情况<br>①    当初始化一个引用成员时；<br>②    当初始化一个常量成员时；<br>③    当调用一个基类的构造函数，而它拥有一组参数时；<br>④    当调用一个成员类的构造函数，而它拥有一组参数时；<br>2)    成员初始化列表做了什么<br>①    编译器会一一操作初始化列表，以适当的顺序在构造函数之内安插初始化操作，并且在任何显示用户代码之前；<br>②    list中的项目顺序是由类中的成员声明顺序决定的，不是由初始化列表的顺序决定的；</p>
<h2 id="18、-构造函数为什么不能为虚函数？析构函数为什么要虚函数？"><a href="#18、-构造函数为什么不能为虚函数？析构函数为什么要虚函数？" class="headerlink" title="18、 构造函数为什么不能为虚函数？析构函数为什么要虚函数？"></a>18、 构造函数为什么不能为虚函数？析构函数为什么要虚函数？</h2><ol>
<li>从存储空间角度，虚函数相应一个指向vtable虚函数表的指针，这大家都知道，但是这个指向vtable的指针事实上是存储在对象的内存空间的。问题出来了，假设构造函数是虚的，就须要通过 vtable来调用，但是对象还没有实例化，也就是内存空间还没有，怎么找vtable呢？所以构造函数不能是虚函数。</li>
<li>从使用角度，虚函数主要用于在信息不全的情况下，能使重载的函数得到相应的调用。构造函数本身就是要初始化实例，那使用虚函数也没有实际意义呀。所以构造函数没有必要是虚函数。虚函数的作用在于通过父类的指针或者引用来调用它的时候可以变成调用子类的那个成员函数。而构造函数是在创建对象时自己主动调用的，不可能通过父类的指针或者引用去调用，因此也就规定构造函数不能是虚函数。</li>
<li>构造函数不须要是虚函数，也不同意是虚函数，由于创建一个对象时我们总是要明白指定对象的类型，虽然我们可能通过基类的指针或引用去訪问它但析构却不一定，我们往往通过基类的指针来销毁对象。这时候假设析构函数不是虚函数，就不能正确识别对象类型从而不能正确调用析构函数。</li>
<li>从实现上看，vbtl在构造函数调用后才建立，因而构造函数不可能成为虚函数从实际含义上看，在调用构造函数时还不能确定对象的真实类型（由于子类会调父类的构造函数）；并且构造函数的作用是提供初始化，在对象生命期仅仅运行一次，不是对象的动态行为，也没有必要成为虚函数。</li>
<li>当一个构造函数被调用时，它做的首要的事情之中的一个是初始化它的VPTR。因此，它仅仅能知道它是“当前”类的，而全然忽视这个对象后面是否还有继承者。当编译器为这个构造函数产生代码时，它是为这个类的构造函数产生代码——既不是为基类，也不是为它的派生类（由于类不知道谁继承它）。所以它使用的VPTR必须是对于这个类的VTABLE。并且，仅仅要它是最后的构造函数调用，那么在这个对象的生命期内，VPTR将保持被初始化为指向这个VTABLE, 但假设接着另一个更晚派生的构造函数被调用，这个构造函数又将设置VPTR指向它的 VTABLE，等.直到最后的构造函数结束。VPTR的状态是由被最后调用的构造函数确定的。这就是为什么构造函数调用是从基类到更加派生类顺序的还有一个理由。可是，当这一系列构造函数调用正发生时，每一个构造函数都已经设置VPTR指向它自己的VTABLE。假设函数调用使用虚机制，它将仅仅产生通过它自己的VTABLE的调用，而不是最后的VTABLE（全部构造函数被调用后才会有最后的VTABLE）。<p style="text-indent: 2em;margin: 0px;padding: 0px">因为构造函数本来就是为了明确初始化对象成员才产生的，然而virtual function主要是为了再不完全了解细节的情况下也能正确处理对象。另外，virtual函数是在不同类型的对象产生不同的动作，现在对象还没有产生，如何使用virtual函数来完成你想完成的动作。</p><br><p style="text-indent: 2em;margin: 0px;padding: 0px">直接的讲，C++中基类采用virtual虚析构函数是为了防止内存泄漏。具体地说，如果派生类中申请了内存空间，并在其析构函数中对这些内存空间进行释放。假设基类中采用的是非虚析构函数，当删除基类指针指向的派生类对象时就不会触发动态绑定，因而只会调用基类的析构函数，而不会调用派生类的析构函数。那么在这种情况下，派生类中申请的空间就得不到释放从而产生内存泄漏。所以，为了防止这种情况的发生，C++中基类的析构函数应采用virtual虚析构函数。</p>

</li>
</ol>
<h2 id="19、-析构函数的作用，如何起作用？"><a href="#19、-析构函数的作用，如何起作用？" class="headerlink" title="19、 析构函数的作用，如何起作用？"></a>19、 析构函数的作用，如何起作用？</h2><p>1)    构造函数只是起初始化值的作用，但实例化一个对象的时候，可以通过实例去传递参数，从主函数传递到其他的函数里面，这样就使其他的函数里面有值了。规则，只要你一实例化对象，系统自动回调用一个构造函数，就是你不写，编译器也自动调用一次。</p>
<p>2)    析构函数与构造函数的作用相反，用于撤销对象的一些特殊任务处理，可以是释放对象分配的内存空间；特点：析构函数与构造函数同名，但该函数前面加<span style="color: red">~</span>。 析构函数没有参数，也没有返回值，而且不能重载，在一个类中只能有一个析构函数。当撤销对象时，编译器也会自动调用析构函数。每一个类必须有一个析构函数，用户可以自定义析构函数，也可以是编译器自动生成默认的析构函数。一般析构函数定义为类的公有成员。</p>
<h2 id="20、构造函数和析构函数可以调用虚函数吗，为什么"><a href="#20、构造函数和析构函数可以调用虚函数吗，为什么" class="headerlink" title="20、构造函数和析构函数可以调用虚函数吗，为什么"></a>20、构造函数和析构函数可以调用虚函数吗，为什么</h2><p>1)    在C++中，提倡不在构造函数和析构函数中调用虚函数；<br>2)    构造函数和析构函数调用虚函数时都不使用动态联编，如果在构造函数或析构函数中调用虚函数，则运行的是为构造函数或析构函数自身类型定义的版本；<br>3)    因为父类对象会在子类之前进行构造，此时子类部分的数据成员还未初始化，因此调用子类的虚函数时不安全的，故而C++不会进行动态联编；<br>4)    析构函数是用来销毁一个对象的，在销毁一个对象时，先调用子类的析构函数，然后再调用基类的析构函数。所以在调用基类的析构函数时，派生类对象的数据成员已经销毁，这个时候再调用子类的虚函数没有任何意义。</p>
<h2 id="21、-构造函数的执行顺序？析构函数的执行顺序？构造函数内部干了啥？拷贝构造干了啥？"><a href="#21、-构造函数的执行顺序？析构函数的执行顺序？构造函数内部干了啥？拷贝构造干了啥？" class="headerlink" title="21、 构造函数的执行顺序？析构函数的执行顺序？构造函数内部干了啥？拷贝构造干了啥？"></a>21、 构造函数的执行顺序？析构函数的执行顺序？构造函数内部干了啥？拷贝构造干了啥？</h2><p>1)    构造函数顺序<br>①    基类构造函数。如果有多个基类，则构造函数的调用顺序是某类在类派生表中出现的顺序，而不是它们在成员初始化表中的顺序。<br>②    成员类对象构造函数。如果有多个成员类对象则构造函数的调用顺序是对象在类中被声明的顺序，而不是它们出现在成员初始化表中的顺序。<br>③    派生类构造函数。<br>2)    析构函数顺序<br>①    调用派生类的析构函数；<br>②    调用成员类对象的析构函数；<br>③    调用基类的析构函数。</p>
<h2 id="22、-虚析构函数的作用，父类的析构函数是否要设置为虚函数？"><a href="#22、-虚析构函数的作用，父类的析构函数是否要设置为虚函数？" class="headerlink" title="22、 虚析构函数的作用，父类的析构函数是否要设置为虚函数？"></a>22、 虚析构函数的作用，父类的析构函数是否要设置为虚函数？</h2><p>1)    C++中基类采用virtual虚析构函数是为了防止内存泄漏。具体地说，如果派生类中申请了内存空间，并在其析构函数中对这些内存空间进行释放。假设基类中采用的是非虚析构函数，当删除基类指针指向的派生类对象时就不会触发动态绑定，因而只会调用基类的析构函数，而不会调用派生类的析构函数。那么在这种情况下，派生类中申请的空间就得不到释放从而产生内存泄漏。所以，为了防止这种情况的发生，C++中基类的析构函数应采用virtual虚析构函数。<br>2)    纯虚析构函数一定得定义，因为每一个派生类析构函数会被编译器加以扩张，以静态调用的方式调用其每一个虚基类以及上一层基类的析构函数。因此，缺乏任何一个基类析构函数的定义，就会导致链接失败。因此，最好不要把虚析构函数定义为纯虚析构函数。</p>
<h2 id="23、-构造函数析构函数可以调用虚函数吗？"><a href="#23、-构造函数析构函数可以调用虚函数吗？" class="headerlink" title="23、 构造函数析构函数可以调用虚函数吗？"></a>23、 构造函数析构函数可以调用虚函数吗？</h2><p>1)    在构造函数和析构函数中最好不要调用虚函数；<br>2)    构造函数或者析构函数调用虚函数并不会发挥虚函数动态绑定的特性，跟普通函数没区别；<br>3)    即使构造函数或者析构函数如果能成功调用虚函数， 程序的运行结果也是不可控的。</p>
<h2 id="24、-构造函数析构函数可否抛出异常"><a href="#24、-构造函数析构函数可否抛出异常" class="headerlink" title="24、 构造函数析构函数可否抛出异常"></a>24、 构造函数析构函数可否抛出异常</h2><p>1)     C++只会析构已经完成的对象，对象只有在其构造函数执行完毕才算是完全构造妥当。在构造函数中发生异常，控制权转出构造函数之外。因此，在对象b的构造函数中发生异常，对象b的析构函数不会被调用。因此会造成内存泄漏。<br>2)    用auto_ptr对象来取代指针类成员，便对构造函数做了强化，免除了抛出异常时发生资源泄漏的危机，不再需要在析构函数中手动释放资源；<br>3)    如果控制权基于异常的因素离开析构函数，而此时正有另一个异常处于作用状态，C++会调用terminate函数让程序结束；<br>4)    如果异常从析构函数抛出，而且没有在当地进行捕捉，那个析构函数便是执行不全的。如果析构函数执行不全，就是没有完成他应该执行的每一件事情。</p>
<h2 id="25、-类如何实现只能静态分配和只能动态分配"><a href="#25、-类如何实现只能静态分配和只能动态分配" class="headerlink" title="25、 类如何实现只能静态分配和只能动态分配"></a>25、 类如何实现只能静态分配和只能动态分配</h2><p>1)    前者是把new、delete运算符重载为private属性。后者是把构造、析构函数设为protected属性，再用子类来动态创建<br>2)    建立类的对象有两种方式：<br>①    静态建立，静态建立一个类对象，就是由编译器为对象在栈空间中分配内存；<br>②    动态建立，A * p = new A();动态建立一个类对象，就是使用new运算符为对象在堆空间中分配内存。这个过程分为两步，第一步执行operator new()函数，在堆中搜索一块内存并进行分配；第二步调用类构造函数构造对象；<br>3)    只有使用new运算符，对象才会被建立在堆上，因此只要限制new运算符就可以实现类对象只能建立在栈上。可以将new运算符设为私有。</p>
<h2 id="26、-如果想将某个类用作基类，为什么该类必须定义而非声明？"><a href="#26、-如果想将某个类用作基类，为什么该类必须定义而非声明？" class="headerlink" title="26、 如果想将某个类用作基类，为什么该类必须定义而非声明？"></a>26、 如果想将某个类用作基类，为什么该类必须定义而非声明？</h2><p>1)    派生类中包含并且可以使用它从基类继承而来的成员，为了使用这些成员，派生类必须知道他们是什么。</p>
<h2 id="27、什么情况会自动生成默认构造函数？"><a href="#27、什么情况会自动生成默认构造函数？" class="headerlink" title="27、什么情况会自动生成默认构造函数？"></a>27、什么情况会自动生成默认构造函数？</h2><p>1)    带有默认构造函数的类成员对象，如果一个类没有任何构造函数，但它含有一个成员对象，而后者有默认构造函数，那么编译器就为该类合成出一个默认构造函数。不过这个合成操作只有在构造函数真正被需要的时候才会发生；如果一个类A含有多个成员类对象的话，那么类A的每一个构造函数必须调用每一个成员对象的默认构造函数而且必须按照类对象在类A中的声明顺序进行；<br>2)    带有默认构造函数的基类，如果一个没有任务构造函数的派生类派生自一个带有默认构造函数基类，那么该派生类会合成一个构造函数调用上一层基类的默认构造函数；<br>3)    带有一个虚函数的类<br>4)    带有一个虚基类的类<br>5)    合成的默认构造函数中，只有基类子对象和成员类对象会被初始化。所有其他的非静态数据成员都不会被初始化。</p>
<h2 id="28、-什么是类的继承？"><a href="#28、-什么是类的继承？" class="headerlink" title="28、 什么是类的继承？"></a>28、 什么是类的继承？</h2><p>1)    类与类之间的关系<br>has-A包含关系，用以描述一个类由多个部件类构成，实现has-A关系用类的成员属性表示，即一个类的成员属性是另一个已经定义好的类；<br>use-A，一个类使用另一个类，通过类之间的成员函数相互联系，定义友元或者通过传递参数的方式来实现；<br>is-A，继承关系，关系具有传递性；<br>2)    继承的相关概念<br>所谓的继承就是一个类继承了另一个类的属性和方法，这个新的类包含了上一个类的属性和方法，被称为子类或者派生类，被继承的类称为父类或者基类；<br>3)    继承的特点<br>子类拥有父类的所有属性和方法，子类可以拥有父类没有的属性和方法，子类对象可以当做父类对象使用；<br>4)    继承中的访问控制<br>public、protected、private<br>5)    继承中的构造和析构函数<br>6)    继承中的兼容性原则</p>
<h2 id="29、什么是组合？"><a href="#29、什么是组合？" class="headerlink" title="29、什么是组合？"></a>29、什么是组合？</h2><p>1)    一个类里面的数据成员是另一个类的对象，即内嵌其他类的对象作为自己的成员；创建组合类的对象：首先创建各个内嵌对象，难点在于构造函数的设计。创建对象时既要对基本类型的成员进行初始化，又要对内嵌对象进行初始化。<br>2)    创建组合类对象，构造函数的执行顺序：先调用内嵌对象的构造函数，然后按照内嵌对象成员在组合类中的定义顺序，与组合类构造函数的初始化列表顺序无关。然后执行组合类构造函数的函数体，析构函数调用顺序相反。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/c/" rel="tag"># c++</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/10/28/机器学习基础02/" rel="next" title="机器学习02">
                <i class="fa fa-chevron-left"></i> 机器学习02
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/11/02/c-面试02/" rel="prev" title="c++面试02">
                c++面试02 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      
        <div id="gitment-container"></div>
      
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/next/tx.jpg" alt="FelixRong">
            
              <p class="site-author-name" itemprop="name">FelixRong</p>
              <p class="site-description motion-element" itemprop="description">这是一个测试博客</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">17</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://plus.google.com/" target="_blank" title="Google">
                      
                        <i class="fa fa-fw fa-google"></i>Google</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://youtube.com/" target="_blank" title="YouTube">
                      
                        <i class="fa fa-fw fa-youtube"></i>YouTube</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1、-引用和指针的区别"><span class="nav-text">1、 引用和指针的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2、-C-中的指针参数传递和引用参数传递"><span class="nav-text">2、 C++中的指针参数传递和引用参数传递</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3、-形参与实参的区别"><span class="nav-text">3、 形参与实参的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4、-static的用法和作用"><span class="nav-text">4、 static的用法和作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5、静态变量什么时候初始化"><span class="nav-text">5、静态变量什么时候初始化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6、-const"><span class="nav-text">6、 const</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7、-const成员函数的理解和应用"><span class="nav-text">7、 const成员函数的理解和应用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8、-指针和const的用法"><span class="nav-text">8、 指针和const的用法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9、mutable"><span class="nav-text">9、mutable</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10、-extern用法"><span class="nav-text">10、 extern用法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11、-int转字符串字符串转int-strcat-strcpy-strncpy-memset-memcpy的内部实现？"><span class="nav-text">11、 int转字符串字符串转int?strcat,strcpy,strncpy,memset,memcpy的内部实现？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12、-深拷贝与浅拷贝？"><span class="nav-text">12、 深拷贝与浅拷贝？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13、C-模板是什么，底层怎么实现的？"><span class="nav-text">13、C++模板是什么，底层怎么实现的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14、C语言struct和C-struct区别"><span class="nav-text">14、C语言struct和C++struct区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15、虚函数可以声明为inline吗"><span class="nav-text">15、虚函数可以声明为inline吗?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#16、类成员初始化方式？构造函数的执行顺序-？为什么用成员初始化列表会快一些？"><span class="nav-text">16、类成员初始化方式？构造函数的执行顺序 ？为什么用成员初始化列表会快一些？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#17、成员列表初始化？"><span class="nav-text">17、成员列表初始化？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#18、-构造函数为什么不能为虚函数？析构函数为什么要虚函数？"><span class="nav-text">18、 构造函数为什么不能为虚函数？析构函数为什么要虚函数？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#19、-析构函数的作用，如何起作用？"><span class="nav-text">19、 析构函数的作用，如何起作用？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#20、构造函数和析构函数可以调用虚函数吗，为什么"><span class="nav-text">20、构造函数和析构函数可以调用虚函数吗，为什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#21、-构造函数的执行顺序？析构函数的执行顺序？构造函数内部干了啥？拷贝构造干了啥？"><span class="nav-text">21、 构造函数的执行顺序？析构函数的执行顺序？构造函数内部干了啥？拷贝构造干了啥？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#22、-虚析构函数的作用，父类的析构函数是否要设置为虚函数？"><span class="nav-text">22、 虚析构函数的作用，父类的析构函数是否要设置为虚函数？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#23、-构造函数析构函数可以调用虚函数吗？"><span class="nav-text">23、 构造函数析构函数可以调用虚函数吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#24、-构造函数析构函数可否抛出异常"><span class="nav-text">24、 构造函数析构函数可否抛出异常</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#25、-类如何实现只能静态分配和只能动态分配"><span class="nav-text">25、 类如何实现只能静态分配和只能动态分配</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#26、-如果想将某个类用作基类，为什么该类必须定义而非声明？"><span class="nav-text">26、 如果想将某个类用作基类，为什么该类必须定义而非声明？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#27、什么情况会自动生成默认构造函数？"><span class="nav-text">27、什么情况会自动生成默认构造函数？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#28、-什么是类的继承？"><span class="nav-text">28、 什么是类的继承？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#29、什么是组合？"><span class="nav-text">29、什么是组合？</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">FelixRong</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  





  
  



  
  





  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/three.min.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/canvas_lines.min.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/canvas_sphere.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("", "");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

  
<script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js">
</script>

</body>
</html>
